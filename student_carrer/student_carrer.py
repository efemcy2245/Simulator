# -*- coding: utf-8 -*-
"""Student-carrer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BOzSjM3pHAn68YU8bthNvPxLWHf4UTu7

QUESTIONS :

GREEN

Evaluate the graduation time and the final grade for the laurea for a MSc course

What factors influence the graduation time of the students

What are the factors that contribute to a faster academic progess at Polito

YELLOW

what is the graduation mark?

years to graduate?

what is the average time to complete the degree?
"""

import numpy as np
import matplotlib.pyplot as plt
import scipy
from scipy.stats import geom
import random
import collections
from collections import Counter
from scipy.stats import t

"""Input parameters:

Total number of courses (of the degree)  

Grade distribution from past             

Number of exams in each session          

Number of sessions per year              

proabability of passing the exam         

Accuracy on the average estimators       

Average number of exams to be taken during each session   

seed

Total number of courses (of the degree)
"""

while True:
    try:
        tot_courses = int(input("Write the number of courses for our simulation: "))
        if tot_courses > 0:
            break
        else:
          print("Please enter with a number major of 0.")
    except ValueError:
        print("Invalid input. Please enter with a positive number.")

"""Number of sessions per year              

"""

while True:
    try:
        session_year = int(input("Write the number of sessions for our simulation: "))
        if session_year > 0:
            break

        else:
          print("Please enter with a number major of 0.")
    except ValueError:
        print("Invalid input. Please enter with a positive number.")

"""Number of exams in each session"""

while True:
    try:
        exams_ = int(input("Write the number of exams per session for our simulation: "))    ##### how many exams we can make per session
        if exams_ > 0:
            break
        else:
          print("Please enter with a number major of 0.")
    except ValueError:
        print("Invalid input. Please enter with a positive number.")

"""proabability of passing the exam"""

while True:
    try:
        average_exam_attempt = int(input("Write the average to be taken during each session: "))
        if average_exam_attempt>0:
            break
        else:
          print("Please enter with a number major of 0")
    except ValueError:
        print("Invalid input. Please enter with an integer number.")

while True:
    try:
        prob = float(input("Write the probability to pass an exam: "))
        if 0 < prob < 1:
            break
        else:
          print("Please enter with a number between 0 and 1 not included.")
    except ValueError:
        print("Invalid input. Please enter with a floating number.")

"""Accuracy on the average estimators"""

while True:
    try:
        CI = float(input("Write the CI for our simulation: "))
        if 0.8 < CI < 1:
            break
        else:
          print("Please enter with a number between 0.8 and 1 not included to have significant value.")
    except ValueError:
        print("Invalid input. Please enter with a number between 0.8 and 1 not included to have significant value.")

while True:
    try:
        ACC = float(input("Write the accuracy for our simulation: "))*100
        if 50 < ACC < 100:
            break
        else:
          print("Too low. Please enter with a number between 0.50 and 1 not included to have significant value.")
    except ValueError:
        print("Invalid input. Please enter with a number between 0.50 and 1 not included.")

"""seed"""

while True:
    try:
        S = int(input("Write the Seed for our simulation: "))
        break
    except ValueError:
        print("Invalid input. Please e1nter with an integer number.")
random.seed(S)

"""the average exam attempt is a distribution, we need to choice a right distribution because we have different attempt dor each session"""

while True:
    try:
        students = int(input("Write the number of students for the first year: "))
        if students>0:
            break
        else:
          print("Please enter with a number maj1or of 0")
    except ValueError:
        print("Invalid input. Please enter with an integer number.")

#### Distribution of Votes as input
distribution =  [ (18,87),(19,62),(20,74),(21,55),(22,99),(23,94),(24,117),(25,117),(26,136),(27,160),(28,215),(29,160),(30,473)]
sum_values=0
for vote , count in distribution:
  sum_values+=count
distributionPercentage=[]
for e , z in distribution:
  distributionPercentage.append( (e , z/ sum_values)  )
print(distributionPercentage)

score, percentage = zip(*distributionPercentage)

# Creating a histogram
plt.bar(score, percentage, color='blue', edgecolor='black')
for x, y in zip(score, percentage):
    plt.text(x, y, str(round(y,2)), ha='center', va='bottom')

# Adding labels and title
plt.xlabel('Grade')
plt.ylabel('Percentage')
plt.title('Grade Distribution of the Previous Year')
plt.grid(True, linestyle='--', linewidth=0.5, alpha=0.7)
plt.minorticks_on()
plt.grid(which='minor', linestyle=':', linewidth=0.5, alpha=0.5)

plt.savefig('GradeDistributionPast.svg', format='svg', bbox_inches='tight')
# Display the plot
plt.show()

"""Stochastic elements

Green

Number of exams taken for each session

pass/no pass accorging to a Bernoulli experiment

Grade distribution
"""

#################### INPUT PARAMETER ####################
print("TOTAL COURSE IN THE SYSTEM FOR A DEGREE: " ,  tot_courses)
print("NUMBER OF SESSION PER YEAR: " ,  session_year)
print("NUMBER OF MAXIMUM EXAM PER SESSION: " ,  exams_ , " (how many at maxixum we can do)" )
print("PROBABILITY TO PASS AND EXAM: " ,  prob)
print("HOW IS ACCURATE THE AVERAGE: " ,  CI)
print("STARTING SEED: " ,  S)
print("HOW MANY ATTEMPT I WILL GET IN ONE SESSION: " ,  average_exam_attempt , " (IS A DISTRIBUTION)")
print("THE PREVIOUS DISTRIBUTION" ,  distribution)
print("NUMBER OF STUDENTS FOR OUR SIMULATION" ,  students)

def randomVote():
  global distributionPercentage
  keys, probabilities = zip(*distributionPercentage)
  random_key = random.choices(keys, weights=probabilities, k=1)[0]
  return random_key

def generate_bernoulli(p):
    outcomes = [0, 1]
    probabilities = [1 - p, p]
    result = random.choices(outcomes, probabilities)[0]    #### we use choice because use a specific probability or an uniform
    return result

# *********************************************
# Student
# *********************************************
class Student:
  def __init__(self , number):
    self.carrierExam = np.zeros(number)
    self.history = []
    self.attempt = 0
    self.avgCarrier = 0
    self.studentGraduated = 0
    self.reject =0
    self.startTime = 0
    self.endTime=0
    self.graduationTime =0
    self.fail=0
    self.failprob=0
    self.avgDelay=[]
    self.finalmark = 0

    self.previousVote = 0    ### after we create the student
    self.noactiv = 0                    ### three metrics
    self.timeSatisfaction = 0           ### time satisfaction
    self.scoreSatisfaction = 0          ### score satisfaction
    self.sumSatisfaction = 0

# ********************************************
# To take the measurements
# ********************************************
class Measure:
    def __init__(self):
        self.vote=0
        self.voteCount=0
        self.gradeDistr= {key: 0 for key in range(18, 31)}
        self.gradTime=[]   #### list of tuple ( time , number of student that finished the graduation ) with these we can build somethings like pdf and cdf
        self.gradeTimeDistribution =  []     #### list of ( timeSystem ,  avgvote)
        self.sumVoteCourse=0
        self.countVoteCourse=0
        self.sumAttempt=0
        self.countAttempt=0

def generate_discrete_random_number_around_n(mean, size=1):
    random_numbers = np.random.poisson(mean, size)
    return random_numbers[0]

def mean_confidence_accuracy(   array ):
  global CI
  mean = array.mean()
  variance = np.var( array ,  ddof=1)
  num_samples = len(array)
  standard_error = np.sqrt(variance / num_samples)
  t_critical = t.ppf((1 + CI) / 2, 1)
  delta= t_critical * (standard_error / np.sqrt(num_samples))
  confidence_interval = (round(mean - delta, 2 ), round( mean + delta,2 )  )   #### the round is used to print the result not for approximate the value of RV
  relative_error = delta / mean
  accuracy = (1 - relative_error  ) *100

  return  mean , confidence_interval, accuracy

def graduationTime( tupleTimeStart ,tupleTimeGrad):
  global session_year
  if(tupleTimeStart[0]!=0):
    sessionStart =  (tupleTimeStart[0]*(session_year+1))+ (tupleTimeStart[1] )
  else:
    sessionStart = tupleTimeStart[1]

  sessionGrad = (tupleTimeGrad[0]*(session_year+1))+ (tupleTimeGrad[1] )
  time = sessionGrad-sessionStart
  tuplatime = sessionToYear(time)
  return tuplatime

def yearToSession ( tupleyear ):
  global session_year
  if(tupleyear[0]!=0):
    session = (tupleyear[0]*(session_year+1)) +tupleyear[1]
  else:
    session = tupleyear[1]
  return session

def sessionToYear ( session   ):
  global session_year
  year = session / (session_year+1)
  decimal_part = year  % 1
  try:
    year = int(year)
    truncated_number = round(decimal_part, 1)
    bin= 1/(session_year+1)
    session= int (round( (truncated_number / bin) ,0  ))
    return (year ,session)
  except ValueError as e:
     return (0 ,0)

def checkStudents(arrayStudentCourse):
  global arrGraduated , data , timeSystem, arrVote ,arrAttempt
  listastudent=[]
  for s in arrayStudentCourse:
    if(s.carrierExam[-1] != 1):
      listastudent.append(s)
    else:
      startTime = s.startTime
      gradTime  = graduationTime ( startTime ,  timeSystem )
      s.endTime = timeSystem
      s.graduationTime= gradTime
      s.avgCarrier =   np.array(s.history ).mean()
      arrVote = np.append(arrVote, s.avgCarrier )

      arrAttempt = np.append(arrAttempt, s.attempt )
      arrGraduated = np.append(arrGraduated, s )
      data.gradTime.append(gradTime)
      data.gradeTimeDistribution.append( (gradTime , s.avgCarrier )   )

  return listastudent

########## OUTPUT : average graduation time and grading time distribution
def mean_confidence_accuracy_Time( ):
  global data, arrGraduated , CI

  list_timegrad = data.gradTime                 ####  trasform the dictionary in list
  tuple_counts = Counter(list_timegrad)
  result_dict = dict(tuple_counts)
  result_list = list(result_dict.items())
 # Sort the list using the custom sorting function

  sorted_list = sorted(result_list, key=lambda x: x[0])

  sum=0
  values = np.array([])

  for  k, v in sorted_list:
    sum+=  (yearToSession(k) * v)
    for n in range(v):
      values = np.append(values, yearToSession(k) )

  mean=values.mean()
  variance = np.var( values ,  ddof=1)
  values = np.append(values, s )
  t_critical = t.ppf((1 + CI) / 2, 1)
  #print(mean)
  mean_tuple= sessionToYear(mean)

  standard_error= np.sqrt(variance  / len(values))
  margin_of_error_time = t_critical * (standard_error / np.sqrt(len(values)))
  #print(margin_of_error_time)
  left_side = round(mean - margin_of_error_time, 2 )               #### the round is used to print the result not for approximate the value of RV
  right_side = round(mean + margin_of_error_time, 2 )              #### the round is used to print the result not for approximate the value of RV

  relative_error = margin_of_error_time / mean
  accuracy = (1 - relative_error  ) *100


  return mean_tuple, (sessionToYear(left_side) , sessionToYear(right_side)), accuracy

def linear_mapping_function(x):
    m = 0.015
    c = 0.2

    x = max(-12, min(x, 12))
    y = m * x + c
    normalized_y = max(0, min(y, 0.4))

    return normalized_y

x_values = list(range(-12, 13))

# Calculate corresponding y values using the linear mapping function
y_values = [linear_mapping_function(x) for x in x_values]

# Plot the graph
plt.plot(x_values, y_values, marker='o', linestyle='-', label="Range Domain [-12 +12]")
plt.title('Grade Satisfaction Linear Mapping Function')
plt.xlabel('Difference Previous Vote and Exam Vote')
plt.ylabel('Satistaction grade')
plt.legend()
plt.savefig('gradeSatisfaction.svg', format='svg', bbox_inches='tight')
plt.grid(True)
plt.show()

def linear_mapping_function_for_time(x):
    # Define slope (m) and intercept (c) based on your requirements
    m = -0.02  # Negative slope
    c = 0.4     # Adjust as needed

    # Ensure x is within the range [0, 7]
    x = max(0, min(x, 7))

    # Calculate y using the linear equation y = mx + c
    y = m * x + c

    # Normalize y to the range [0, 0.4]
    normalized_y = max(0, min(y, 0.4))

    return normalized_y

# Generate x values from 0 to 7
x_values_new_range_negative_slope = list(range(10))

# Calculate corresponding y values using the modified linear mapping function
y_values_new_range_negative_slope = [linear_mapping_function_for_time(x) for x in x_values_new_range_negative_slope]

# Plot the graph
plt.plot(x_values_new_range_negative_slope, y_values_new_range_negative_slope, marker='o', linestyle='-')
plt.title('Time Satisfaction Linear Mapping Function')
plt.xlabel('Time (Year)')
plt.ylabel('Satistaction Time')
plt.savefig('timeSatisfaction.svg', format='svg', bbox_inches='tight')
plt.grid(True)
plt.show()

### set variables
boolean = True
timeSystem = (0, 0)    ##### Year - month
studentsGraduated=[]
arrayStudentCourse= np.empty(0)
data = Measure()

for el in range(students):
  s=Student(tot_courses)
  s.startTime=timeSystem
  arrayStudentCourse = np.append(arrayStudentCourse, s)

### after we can delete
for s in arrayStudentCourse:
  print()
  random_number = random.uniform(18, 30)
  s.previousVote = random_number
  print(s.previousVote)
  print(s.carrierExam)

print()
################  there is a warning on the output because we compute for the first loops a variance with only one sample in the command np.var( array ,  ddof=1)

arrVote = np.array([])    ###### this is for the students graduated for each is the avg
arrAttempt = np.array([])   #### number of attempts per student
arrGraduated = np.array([])   #### array of students graduated

while boolean:
  ##### new enrollment
  if(timeSystem[0]!=0):
    N = generate_discrete_random_number_around_n(students)    #### for the new year we have new enrollment
    for el in range(N):
      s=Student(tot_courses)                                                     ### in a new year we enroll N students
      s.startTime=timeSystem                                                     ### saving the time in which is enrolled
      arrayStudentCourse = np.append(arrayStudentCourse, s)

  if(len(arrGraduated)!=0):                                                      ### if we have at least one studentgraduated we can check the sate
    avg_time , conf_time , accuracyTime= mean_confidence_accuracy_Time()         ### we stop the experiment if we have a good accuracy

    if(accuracy_vote>ACC and accuracy_attempt>ACC and accuracyTime>ACC ):
      print("vote acc : " , accuracy_vote  , " accuracy attempt ",accuracy_attempt  , " accuracy time ",accuracyTime  )
      break

  print(timeSystem , " number of students in the course  " ,len(arrayStudentCourse), "number of student graduated ", len(arrGraduated))
  for sy in range(session_year):  #### loop for session
    arrayStudentCourse =  checkStudents(arrayStudentCourse)   #### we pop the arrayStudentCourse if he has completed the graduation #### in the method we load the array for termination loop

    if(len(data.gradTime)!=0):
          mean_vote , conf_vote , accuracy_vote = mean_confidence_accuracy( arrVote)             #### compute the statistics for termination loop
          mean_attempt , conf_attempt , accuracy_attempt = mean_confidence_accuracy( arrAttempt)


    timeSystem= ( timeSystem[0] , sy+1 )    ##### Year - month - tuple is an immutable object

    if(len(arrayStudentCourse)==0):
      boolean=False
      break
    for student in arrayStudentCourse:
        maximumtrial = np.random.poisson(average_exam_attempt)   ######## stochastic element the number of exam that is taken in one session, in based on
                                                                 ######## the average_exam_attempt, is around it

        if(maximumtrial>exams_):                                #### if a student take a number higher than the threshold, the number is set to the max threshold
          maximumtrial=exams_

        for mt in range(maximumtrial):                          ### we try the exams for max-trial
          result = generate_bernoulli(prob)

          if(result ==1 ):                                     ## if i pass the exam
            #### here we define the decision making
            #### modify the obj student
            student.noactiv = random.uniform(0, 0.2)      ##### after we can mean this value
            # How i can understand if it a good mark for me?
            vote = randomVote()                            ### i can add that vote in the carrier
            diffvote = student.previousVote - vote
            increasevote = linear_mapping_function(diffvote)/2
            vote = round(vote + vote*increasevote)
            if(vote<=18):
              vote=18
            elif(vote>=30):
              vote=30
                                                                      #### this diffenrece is bewtween -12 and +12 the worst or the best case
            student.previousVote =  (student.previousVote + vote ) /2    #### this is important for the next iteration because the student wants better
            if(student.scoreSatisfaction==0):                               ###this for the first loop , can be define after generating the student
              student.scoreSatisfaction = linear_mapping_function(diffvote)    #### in this way we avoid always to write the loop
            else:
              satisfaction = linear_mapping_function(diffvote)
              student.scoreSatisfaction = satisfaction  ### alto valore delle funzioni migliore probabilita

                                                                                           ### di non rifiutare il voto

            student.timeSatisfaction = linear_mapping_function_for_time(timeSystem[0])  #### model the time
            # print(  student.timeSatisfaction, student.scoreSatisfaction , student.noactiv  )

            student.sumSatisfaction = student.noactiv + student.scoreSatisfaction + student.timeSatisfaction ### this value change dynamically
            print( student.sumSatisfaction )


            reject = generate_bernoulli(1-student.sumSatisfaction)  ### prob to reject the vote, we use the information of passing the exam and compute the prob
            if(reject==0):                                          ### as 1-p
              if(len(student.history)!=tot_courses):                ### if we do not reject and the array of hystory is different to the len of the courses then
                                                                    ### i can add that vote in the carrier
                student.history.append(vote)                        ### if the len is equal it means that the student had finished the exam and will be processed
                data.vote+=vote                                     ### in the method check student
                data.voteCount+=1
                data.gradeDistr[vote]+=1
                student.attempt+=1
                student.failprob = student.fail/ student.attempt

              counter=0
              for carEx in student.carrierExam:                ### we find a slot that has 0 and convert it in 1 to add the exam
                if(carEx==0):
                  student.carrierExam[counter]=1               ### we use the counter to check the index
                  break
                counter+=1
            else:
              student.avgDelay.append(timeSystem)
              student.reject+=1
              student.attempt+=1
          else:
            student.attempt+=1
            student.fail+=1
            student.failprob = student.fail/ student.attempt
    if(sy+1==session_year):                                   ### if the session is the maximum +1 then we can go to the next year
      timeSystem= ( timeSystem[0]+1 , 0 )

def randommotivation(x):
    # Ensure x is within the range -12 to +12
    x = max(min(x, 12), -12)

    # Calculate the mapped value
    mapped_value = (x + 12) / 24 * 0.2

    return mapped_value
# Generate input values
input_values = list(range(-15, 16))

# Calculate corresponding mapped values
mapped_values = [randommotivation(x) for x in input_values]

# Plot the graph
plt.plot(input_values, mapped_values, marker='o')
plt.title('Mapping Function: Input vs Percentage')
plt.xlabel('Input Value')
plt.ylabel('Percentage')
plt.grid(True)
plt.show()

"""BIG QUESTION : IF THE INPUT DISTIRBUTION IS ALWAYS THE SAME AND THE EXAM IS DONE WITH BERNOULLI DISTRIBUTION; HOW I CAN SEE AN IMPROVEMENT IF THE DISTRIBUTION IS ALWAYS THE SAME AND ALSO THE ATTEMPT? BECAUSE IF I REPEAT THE EXAM I AM GUESSING THAT THE DISTRIBUTION IS THE PREVIOUS WITHOUT UPDATING AND IF I WILL REPEAT AN EXAM PROBABLY I CAN GET A MARK HIGHER

OUTPUT : graduation grade distribution  -  average graduation grade and average number of attempts
"""

########## OUTPUT : graduation grade distribution


list_Distribution = list(data.gradeDistr.items())

sum_values=0
for vote , count in list_Distribution:
  sum_values+=count
distrPercentage=[]
for e , z in list_Distribution:
  distrPercentage.append( (e , z/ sum_values)  )

print("vote acc : " , accuracy_vote  , " accuracy attempt ",accuracy_attempt  , " accuracy time ",accuracyTime  )

# Extracting ages and values
score, percentage = zip(*distrPercentage)

# Creating a histogram
plt.bar(score, percentage, color='blue', edgecolor='black', label=f"Grade AVG={round(mean_vote,2)} - CI={conf_vote} - Acc={round(accuracy_vote,2)}\n\
Attempts AVG={round(mean_attempt,2)} - CI={conf_attempt} - Acc={round(accuracy_attempt,2)}")

for x, y in zip(score, percentage):
    plt.text(x, y, str(round(y,2)), ha='center', va='bottom')

# Adding labels and title
plt.xlabel('Grade')
plt.ylabel('Percentage')
plt.title('Grade Distribution')
plt.legend(loc="upper left")
#plt.grid()
plt.grid(True, linestyle='--', linewidth=0.5, alpha=0.7)
plt.minorticks_on()
plt.grid(which='minor', linestyle=':', linewidth=0.5, alpha=0.5)
plt.savefig('GradeDistribution.svg', format='svg', bbox_inches='tight')


plt.show()

"""OUTPUT : average graduation time and grading time distribution"""

########## OUTPUT : average graduation time and grading time distribution

list_timegrad = data.gradTime                 ####  trasform the dictionary in list
tuple_counts = Counter(list_timegrad)
result_dict = dict(tuple_counts)

result_list = list(result_dict.items())

sorted_list = sorted(result_list, key=lambda x: x[0])

coordinates, values = zip(*sorted_list)

x_values = [str(coord) for coord in coordinates]

minimum = str(min(coordinates))
maximum = str(max(coordinates))

plt.bar(x_values, values, label=f"Graduation time\nAVG = {avg_time} \nCI={conf_time} \nACC={round(accuracyTime,2)}")


if avg_time in [item for item in x_values]:
    mean_v =avg_time
else:
    median_index = len(x_values) // 2
    mean_v=x_values[median_index]

#9plt.xticks([minimum, str(mean_v),  maximum   ])

#plt.yticks(([min(values), max(values)  ]))
plt.grid(True, linestyle='--', linewidth=0.5, alpha=0.7)
plt.minorticks_on()
plt.grid(which='minor', linestyle=':', linewidth=0.5, alpha=0.5)


plt.xlabel('Graduation Time in ( Year , Session )')
plt.ylabel('Graduated Students Count')
plt.title('Graduation Time Distribution')
plt.legend( loc= 'upper right',fontsize='small' )
plt.savefig('TimeDistribution.svg', format='svg', bbox_inches='tight')
plt.show()

##### Average delay of declining a grade on the graduation time

lista=[]
for s in arrGraduated:
  #print(" time ", s.graduationTime, " how many we reject" , len(s.avgDelay) )
  lista.append( ( s.graduationTime , len(s.avgDelay)   )   )

dictionary={}

for key, value in lista:
    if key not in dictionary:
        dictionary[key] = [value]
    else:
        dictionary[key].append(value)

dictionary = dict(sorted(dictionary.items()))

x_values = list(dictionary.keys())
y_values = list(dictionary.values())

for x, y_vals in zip(x_values, y_values):
    plt.scatter([str(x)] * len(y_vals), y_vals)

min_y = min(min(y_vals) for y_vals in y_values)
max_y = max(max(y_vals) for y_vals in y_values)
plt.yticks(np.arange(min_y, max_y + 1, 1))


plt.grid(True, linestyle='--', linewidth=0.5, alpha=0.7)
plt.minorticks_on()
plt.grid(which='minor', linestyle=':', linewidth=0.5, alpha=0.5)
plt.xlabel('Graduation Time in ( Year , Session )')
plt.ylabel('Rejected Grades Number')
plt.title('Graduation Time based on Rejected Grades')
plt.savefig('rejectedVote.svg', format='svg', bbox_inches='tight')

plt.show()

######## grade according to the time distribution
get_data = data.gradeTimeDistribution

# Organize the data into a dictionary
organized_dict = {}
for (x, y) in get_data:
    if x not in organized_dict:
        organized_dict[x] = []
    organized_dict[x].append(y)

organized_dict = dict(sorted(organized_dict.items()))


x_values = list(organized_dict.keys())
y_values = list(organized_dict.values())


for x, y_vals in zip(x_values, y_values):
    plt.scatter([str(x)] * len(y_vals), y_vals)

min_y = min(min(y_vals) for y_vals in y_values)
max_y = max(max(y_vals) for y_vals in y_values)
plt.yticks(np.arange(min_y, max_y + 0.25, 0.25))

every_two_values = x_values[::1]
string_list = [str(element) for element in every_two_values]

plt.xticks(string_list)



plt.grid(True, linestyle='--', linewidth=0.5, alpha=0.7)
plt.minorticks_on()
plt.grid(which='minor', linestyle=':', linewidth=0.5, alpha=0.5)
plt.xlabel('Graduation Time')
plt.ylabel('Average Graduation Grade')
plt.xlabel('Graduation Time in ( Year , Session )')
plt.title('Graduation Score according to the Time')
plt.savefig('GradeTimeDistribution.svg', format='svg', bbox_inches='tight')


plt.show()

#arrGraduated graduation time vs probability of failure

lista = []

for s in arrGraduated:
  lista.append(  ( s.graduationTime ,  round(s.failprob,2  )   )  )

######## grade according to the time distribution
print(lista)

result_dict = {}

for key, value in lista:
    if key not in result_dict:
        result_dict[key] = [value]
    else:
        result_dict[key].append(value)
result_dict = dict(sorted(result_dict.items()))

x_values = list(result_dict.keys())
y_values = list(result_dict.values())

for x, y_vals in zip(x_values, y_values):
    plt.scatter([str(x)] * len(y_vals), y_vals)

min_y = min(min(y_vals) for y_vals in y_values)
max_y = max(max(y_vals) for y_vals in y_values)
plt.yticks(np.arange(min_y, max_y + 0.05, 0.05))

#every_two_values = x_values[::2]
#string_list = [str(element) for element in every_two_values]

#plt.xticks(string_list)



plt.grid(True, linestyle='--', linewidth=0.5, alpha=0.7)
plt.minorticks_on()
plt.grid(which='minor', linestyle=':', linewidth=0.5, alpha=0.5)
plt.xlabel('Graduation Time in ( Year , Session )')
plt.ylabel('Probability of Failure')
plt.title('Probability of Failure Correlated to the Graduation Time')
plt.savefig('FailureDistribution.svg', format='svg', bbox_inches='tight')
plt.show()

def finalMark( vote ):
  cents= (vote/30) * 110
  finalgrade   = cents +  np.random.uniform(0, 4) + np.random.uniform(0, 2) + np.random.uniform(0, 2)  #### final grade + thesis + presentation + bonus point
  if( finalgrade>= 112.5):
    finalgrade=111    ##### it is to trace who has the lode
  return finalgrade

listafinalmark=[]
dictionary_final={}
for s in arrGraduated:
  s.finalmark= int(round(finalMark(s.avgCarrier),0))
  listafinalmark.append( ( s.graduationTime , s.finalmark )     )


for key, value in listafinalmark:
    if key not in dictionary_final:
        dictionary_final[key] = [value]
    else:
        dictionary_final[key].append(value)
dictionary_final = dict(sorted(dictionary_final.items()))

print(dictionary_final)

x_values = list(dictionary_final.keys())
y_values = list(dictionary_final.values())

for x, y_vals in zip(x_values, y_values):
    plt.scatter([str(x)] * len(y_vals), y_vals)

min_y = min(min(y_vals) for y_vals in y_values)
max_y = max(max(y_vals) for y_vals in y_values)


plt.yticks(np.arange(min_y, max_y + 1, 1))

plt.grid(True, linestyle='--', linewidth=0.5, alpha=0.7)
plt.minorticks_on()
plt.grid(which='minor', linestyle=':', linewidth=0.5, alpha=0.5)
plt.xlabel('Graduation Time in ( Year , Session )')
plt.ylabel('Final Grade')
plt.title('Correlation Final Grade and Graduation Time')
plt.savefig('FinalGradeTIme.svg', format='svg', bbox_inches='tight')
plt.show()

final= np.array([])
for el in arrVote:
  grade = int(round(  finalMark(el),0))
  final = np.append(final, grade )
print(final)

final= np.array([])
for el in arrVote:
  grade = int(round(  finalMark(el),0))
  final = np.append(final, grade)

mean_final , conf_final , accuracy_final = mean_confidence_accuracy( final)
grade_counts = dict(zip(*np.unique(final, return_counts=True)))
grade_ordered = dict(sorted(grade_counts.items()))


x_values = list(grade_ordered.keys())
y_values = list(grade_ordered.values())


if 111 in [item for item in x_values]:
    lode = "110 with Lode"

x_values = ["110L" if x == 111 or x==112 else str(int(x)) for x in x_values]

plt.bar(x_values, y_values, label=f"Final Grade\nAVG = {round(mean_final,2)} \nCI={conf_final} \nACC={round(accuracy_final,2)}")

#plt.xticks(x_values[::1])
#plt.yticks(([min(values), max(values)  ]))
plt.grid(True, linestyle='--', linewidth=0.5, alpha=0.7)
plt.minorticks_on()
plt.grid(which='minor', linestyle=':', linewidth=0.5, alpha=0.5)


plt.xlabel('Final Grade of the MSc')
plt.ylabel('Students Count')
plt.title('Relationship Students Count and Final Grade ')
plt.legend( loc= 'upper left',fontsize='small' )
plt.savefig('FinalGrade.svg', format='svg', bbox_inches='tight')
plt.show()