# -*- coding: utf-8 -*-
"""G6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_ZZthfrD9P4kvbJbmXCXPPbV_vM7ciKT
"""

import numpy as np
from numpy.random import exponential , poisson , uniform , choice

while True:
    try:
        pop = int(input("Write the number of population: "))
        if pop > 0:
            break
        else:
          print("Please enter with a number major of 0.")
    except ValueError:
        print("Invalid input. Please enter with a positive-integer number.")

while True:
    try:
        lambdarate = int(input("Write the number of rate per event: "))
        if lambdarate > 0:
            break
        else:
          print("Please enter with a number major of 0.")
    except ValueError:
        print("Invalid input. Please enter with a positive-integer number.")

while True:
    try:
        alpha = int(input("Write the improvement factor: "))
        if alpha >= 0:
            break
    except ValueError:
        print("Invalid input. Please enter with a positive-integer number.")

while True:
    try:
        prob_improve = float(input("Write the probability that the next gen will improve: "))
        if 0<prob_improve<1:
            break

        else:
          print("Please enter with a number between 0 and 1.")
    except ValueError:
        print("Invalid input. Please enter with a floating point between 0 and 1.")

while True:
    try:
        mean_exp = int(input("Write the mean rate for the life tyme: "))
        if mean_exp > 0:
            break
    except ValueError:
        print("Invalid input. Please enter with a positive-integer number.")

reproduction_rate = [  1, 2, 3 ]
improv_prob = [ 0.3 , 0.4 , 0.5 , 0.6 , 0.7   ]

##### object for the simulation
class Measure:
    def __init__(self):
        self.extinction = False
        self.born = 0
        self.death = 0
        self.hyperpar_sim=""
        self.ext_time = None
        self.gen = None


# *********************************************
# SPECIES
# *********************************************
class Specie:
    def __init__( self , id , generation, father , born, parentlife):
        self.id = id
        self.generation = generation
        self.father = father
        self.timeborn = born
        self.death = None
        self.parentlife = parentlife

def born( spec , time ):
  global timesystem , FES , POP , id , prob_improve , alpha , lambdarate, data

  timesystem = time
  numberchild = poisson(lambdarate)
  father = spec
  death = father.death
  gen = father.generation
  timeabs = death - time
  data.born+=1
  """
  print("#############################")
  print("number child    ", numberchild )
  print(  " father death is:  ", death , " the lifetime is: ", timeabs  )
  """

  for el in range(numberchild):                      #### we check the generation in the time of the simulation, if the while event has an expire date
    timebornchild =  uniform(time , death )
    result = choice([0, 1], p=[1-prob_improve, prob_improve])

    if(result == 1  ):    ##### improvement

      leftside = timeabs*(1 + alpha)
      newlife = np.random.uniform(timeabs, leftside)

      child = Specie( id , gen+1 , father , timebornchild , timeabs )
      child.death =  timebornchild + newlife
      """
      print("#################################")
      print("the lifetime is improved")
      print("the child is born in : " , timebornchild )
      print("the lifetime is  :" , newlife)
      print("the child will die in : " , child.death )
      """

      FES.append( ( "DEATH", child , child.death )  )

      FES.append( ( "BORN" , child , timebornchild )  )
      POP.append(child)
      id+=1
    else:                 ##### no improvement

      newlifetime = uniform(0 , timeabs )
      child = Specie( id , gen+1 , father , timebornchild , timeabs )
      child.death =  timebornchild + newlifetime

      """
      print("#################################")
      print("the lifetime is not-improved")
      print("the child is born in : " , timebornchild )
      print("the lifetime is  : " , newlifetime)
      print("the child will die in : " , child.death )
      print("the lifetime of the father was : " , timeabs )
      """
      id+=1

def death( spec , time ):
  global timesystem , FES , POP , id , prob_improve , alpha , lambdarate , graveyard , data

  timesystem = time
  obj = spec
  id_obj= obj.id
  for index, value in enumerate(POP):
    if value.id == id_obj:
        break  # Exit the loop once the object is found
  graveyard.append( POP.pop(index) )
  data.death+=1

reproduction_rate = [  1, 2, 3, 4 , 5 ]
improv_prob = [ 0.3 , 0.4 , 0.5 , 0.6 , 0.7 , 0.8 , 0.9 ]

#reproduction_rate = [  1]
#improv_prob = [ 0.3]

container_simulation=  []

for a in reproduction_rate:
  for b in improv_prob:
      print("simulation with hyper-parameters   : ", a , "   " , b )

      i=0
      timesystem=0
      data = Measure()
      lambdarate = a
      prob_improve = b
      data.hyperpar_sim = f" the reproduction rate is {a} improve_prob is {b}"
      FES = []     # future-event set
      POP = []
      graveyard = [ ]
      ##### inizialization first pop
      ###   LAMBDA is equal to event * time (second)
      generation = 0
      id=0
      father= None
      parentlifetime = 0

      for specs in range(pop):
        spec= Specie( id , generation , father , timesystem , parentlifetime )
        timelife= exponential(scale=mean_exp) *1   ##### we have to set also the the estimating time for understand if it is coherent with reality
        timedeath = timesystem + timelife
        spec.death = timedeath
        event = ( "BORN" , spec , timesystem    )
        FES.append(event)
        POP.append(spec)
        id+=1
      for element in POP:
        event= ( "DEATH" , element, element.death )
        FES.append(event)
      ########################################Ã  while loop with termination criteria using the time,for each loop is pop one event from the FES
      #### after every loop sort the fes

      try:
        #while True:
        #while timesystem<=100:
        while i< 10000 :
            i+=1
            event = FES.pop(0)
            tag= event[0]
            timesystem = event[2]
            print("event " , tag , " cycle number ", i, " the time system is " , timesystem   )

            if(tag=="BORN"):
              born(event[1], event[2]  )
              FES = sorted(FES, key=lambda x: (x[2], x[0]))
            elif(tag=="DEATH"):
              death(event[1], event[2])
              FES = sorted(FES, key=lambda x: (x[2], x[0]))
            if(i==10000):
              break
        container_simulation.append(data)
      except IndexError:
        data.extinction= True

        data.ext_time = timesystem
        max_gen=0
        for genElem in graveyard:
          if( genElem.generation > max_gen ):
            max_gen= genElem.generation
        data.gen = max_gen

        container_simulation.append(data)
        print("extinction")
      print()
      print()
      print("THE SIMULATION IS FINISHED")
      print("the popolution is equal to : ", len(POP) , "with number of events " , len(FES))
      print()
      print()

for row in container_simulation:
  print( row.hyperpar_sim)
  print( "Extinction : " , row.extinction)
  if( row.extinction == True   ):
    print( "the extinction time is ", row.ext_time)
    print( "the last gen is :", row.gen)
  print(row.born , " &  " , row.death)
