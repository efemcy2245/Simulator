# -*- coding: utf-8 -*-
"""G7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pdqT0TOwUNNfiFCEsZrLY61LvOcNm_TE
"""

#  rgbif or pygbif download dataset from GBIF

import pandas as pd
import numpy as np
from numpy.random import exponential , poisson , uniform , choice
import math
from math import sqrt
import random
from random import randint
from scipy.stats import t
import time
import copy
import matplotlib.pyplot as plt

# Zoo Animal Classification dataset URL from UCI ML Repository
url = "https://archive.ics.uci.edu/ml/machine-learning-databases/zoo/zoo.data"

# Define column names
column_names = ["animal_name", "hair", "feathers", "eggs", "milk", "airborne",
                "aquatic", "predator", "toothed", "backbone", "breathes", "venomous",
                "fins", "legs", "tail", "domestic", "catsize", "class_type"]

# Read the dataset into a pandas DataFrame
df = pd.read_csv(url, header=None, names=column_names)
#print(df.head())

#df   uncomment to see the entire dataset

condition = (df['aquatic'] == 0  )
filtered_df = df[condition]
df = filtered_df.drop(columns= ['class_type','eggs', 'milk','breathes']   )
df.reset_index(drop=True, inplace=True)


df.head()   ### Dataset filtered using only ground animals

column_name = 'animal_name'                         #### list of animals for the dictionary
name_animals = []
for index, value in df[column_name].items():
    name_animals.append(value)

while True:
    try:
        CI = float(input("Write the CI for our simulation: "))
        if 0.8 < CI < 1:
            break
        else:
          print("Please enter with a number between 0.8 and 1 not included to have significant value.")
    except ValueError:
        print("Invalid input. Please enter with a number between 0.8 and 1 not included to have significant value.")

# *********************************************
# SPECIES
# *********************************************
class Specie:
    def __init__( self , id , generation, father , born, parentlife):
        self.name = None
        self.id = id
        self.generation = generation
        self.father = father
        self.timeborn = born
        self.death = None
        self.parentlife = parentlife    #######done by inizialization
        self.position = None
        self.mobility= None
        self.velocity = None
        self.lethality = None
        self.features = {}
        self.mobilityfeatures = None
        self.lethalityfeatures = None

##### object for the simulation
class Measure:
    def __init__(self):
        self.extinction = False
        self.rate = None  # {value: (0,0) for value in name_animals}
        self.ext_time = None
        self.gen = {}  # {value: (0,0) for value in name_animals}
        self.time = None
        #### inserire dictionary    gen  , (    lifetime , count )

# define the mobility
def mobility( animal ):
  obj = animal
  listmob = [ "legs", "catsize" , "backbone" , "airborne" ]
  legsmob = { 0: 0.2 , 2: 0.5 , 4: 0.8 , 6: 0.9 , 8: 0.1 }
  catsizemob = { 1: -0.30 , 0: 0  }
  backbonemod = { 0: -0.1,  1: 0.1 }
  airborne = { 0: 0 , 1: 0.3   }
  features = obj.features

  values_to_access = [features[key] for key in listmob]
  percentage = legsmob[values_to_access[0]] + catsizemob[values_to_access[1]] + backbonemod[values_to_access[2]] + airborne[values_to_access[3]]


  if(percentage>=1 ):
    percentage = 0.95
  if(percentage <= 0):
    percentage = 0.05
  #print("value is ",percentage)
  obj.mobility= percentage

  obj.mobilityfeatures = values_to_access

  return obj

def lethality(obj):
  listmob = [ "predator" , "toothed" , "venomous", "domestic" ]
  pred = {   0: 0.20 , 1 : 0.60  }
  toothed = { 0: 0    , 1: 0.2   }
  venomous = { 0: 0,  1: 0.3  }
  domestic = { 0: 0,  1: -0.1  }
  features = obj.features

  values_to_access = [features[key] for key in listmob]
  percentage = pred[values_to_access[0]] + toothed[values_to_access[1]] + venomous[values_to_access[2]] + domestic[values_to_access[3]]
  #print(percentage)

  if(percentage>=1 ):
    percentage = 0.95
  if(percentage <= 0):
    percentage = 0.05
  #print("value is ",percentage)
  obj.lethality= percentage

  obj.lethalityfeatures = values_to_access

  return obj

#probabilita di soppravvivenza numero di scontri vinti  diviso tutti i numeri

#### la accuracy della misura

def copyfeatures( child, father ):

  child.position = father.position
  child.mobility = father.mobility
  child.lethality = father.lethality
  child.velocity = father.velocity
  child.features = father.features
  child.mobilityfeatures = father.mobilityfeatures
  child.lethalityfeatures = father.lethalityfeatures
  child.name = father.name

  return child

def improvefeatures(child):
  child.lethality =   child.lethality*1.01
  child.velocity =  child.velocity*1.01
  if(child.lethality >= 1):
    child.lethality = 0.95
  if(child.lethality <= 0):
    child.lethality = 0.05
  if(child.mobility >= 1):
    child.mobility = 0.95
  if(child.mobility <= 0):
    child.mobility = 0.05
  child.velocity = 1e4 * child.mobility #### 10000 = 10km * percentage mobility
  return child

def movement():
  global population
  for p in population:
    pos = p.position
    velocity= int(p.velocity) ### maximum velocity in x and y
    signx = choice([0, 1], p=[1-0.5, 0.5])  ### movement positive or negative in x axis
    signy = choice([0, 1], p=[1-0.5, 0.5])  ### movement positive or negative in y axis
    x = randint( 0 , velocity  )         ##### choice a random int number from the 0 and the maximum velocity in axis-x
    y = randint( 0 , velocity  )         ##### choice a random int number from the 0 and the maximum velocity in axis-y

    if( signx==1 ):                  #####
      x = -x                  ### x  negative sign = movement negative
    if( signy==1 ):
      y = -y                  ### y  negative sign = movement negative
    new_x = pos[0] + x
    new_y = pos[1] + y

    if(  new_x > 1e6 ):       ####  check if the movement if outside 0 or 1e6 for x and y
      new_x =  pos[0] -x      #### if one condition is true the movement is toward the internal side
    elif( new_x < 0):
      new_x = pos[0] - x
    if(  new_y > 1e6 ):
      new_y =  pos[1] -y
    elif( new_y < 0):
      new_y = pos[1] - y
    p.position = ( new_x  , new_y )

def death( spec , time ):
  global timesystem , FES , population , id , prob_improve , alpha , lambdarate , graveyard , data

  timesystem = time
  obj = spec
  id_obj= obj.id

  tupla = data.rate[ obj.name ]
  new_tuple = (tupla[0] , tupla[1]+1)
  data.rate[ obj.name ]  = new_tuple

  #value = data.gen.get(obj.generation)
  #print(value)
  v=data.gen.get( obj.generation, (0, 0))
  data.gen[ obj.generation ] =  (  v[0] + ( timesystem - obj.timeborn ) , v[1] + 1 )

  for index, value in enumerate(population):
    if value.id == id_obj:
      population.pop(index)
      break  # Exit the loop once the object is foun

def compute_aggregation(  measure ):
  dictio = {}
  for k , v in measure.rate.items():
    survival_rate = 0
    if(v[0]==0 and v[1]!=0  ):
      survival_rate=0
    elif(v[1]==0):
      survival_rate = 1
    elif(v[0]!=v[1]):
      survival_rate = v[1] / v[0]
    else:
      survival_rate = 0
    dictio[k] = survival_rate

  return dictio

def calculate_distance(point1, point2):
    x1, y1 = point1
    x2, y2 = point2
    distance = sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return int(distance)    #### distance in meters

def fight_escape( first , second  ):
  global population
  first_animal= population[first]                       ####change pop in population
  second_animal = population[second]                    # we use the boolean to understand if is dead someone
  random_number = randint(0, 3)
  if( random_number == 0):                       #######  ATTACK - ESCAPE    ### can die or nothing
    vel_first = first_animal.velocity
    vel_second = second_animal.velocity

    if( vel_first>vel_second ):
      population[second].lethality = first_animal.lethality * 1.01         ### die the second animal , we increase its lethality
      return ( True , second )
    else:
      population[second].velocity = second_animal.velocity* 0.99           ### escape the second animal, the velocity of the second
      population[second].mobility = second_animal.mobility* 0.99           ### is decrease

      return ( False , first   )     ##### nothing happen

  if( random_number == 1):                       ####### ATTACK - ATTACK    ### one must die
    lethality_first = first_animal.lethality
    lethality_second = second_animal.lethality
    if( lethality_first > lethality_second ):
      population[first].lethality = first_animal.lethality * 0.99          ### after a fight the winner animal loses its lethality, the second die
      return ( True , second )
    else:
      population[second].lethality = second_animal.lethality * 0.99        ### after a fight the winner animal loses its lethality, the first die
      return ( True , first )

  if( random_number == 2):                       ####### ESCAPE - ESCAPE   nothing
    vel_first = first_animal.velocity
    vel_second = second_animal.velocity
    population[first].velocity = first_animal.velocity* 0.99            ### escape both animals, the velocities are decreased
    population[first].mobility = first_animal.mobility* 0.99
    population[second].velocity = second_animal.velocity* 0.99
    population[second].mobility = second_animal.mobility* 0.99

    return ( False , first   )

  if( random_number == 3):                       #######  ESCAPE - ATTACK    ### can die or nothing
    vel_first = first_animal.velocity
    vel_second = second_animal.velocity
    if( vel_first>vel_second ):
      population[first].velocity = second_animal.velocity* 0.99        ### escape the first animal, the velocity of the first is decrease
      population[first].mobility = second_animal.mobility* 0.99
      return ( False , first )
    else:
      population[second].lethality = first_animal.lethality * 1.01     ### die the first animal , we increase the lethality of the second
      return ( True , first   )

def born( spec , time ):
  global timesystem , FES , population , id , prob_improve , alpha , lambdarate, data

  timesystem = time
  numberchild = poisson(lambdarate)
  father = spec
  death = father.death
  gen = father.generation
  timeabs = death - time

  for el in range(numberchild):
    epsilon = 1e-10  # A small positive value close to zero
    timebornchild =  uniform( epsilon , timeabs ) #####time in which the child is born , is impossible that the father and child born in the same time
    result = choice([0, 1], p=[1-prob_improve, prob_improve])
    if(result == 1  ):    ##### improvement

        leftside = timeabs*(1 + alpha)
        newlife = np.random.uniform(timeabs, leftside)

        child = Specie( id , gen+1 , father , timesystem + timebornchild , timeabs )
        child.death =  timesystem + timebornchild + newlife

        child =  copyfeatures( child, father )      ####### save features of the animal

        improve = choice([0, 1], p=[1-0.5, 0.5])
        if(improve == 1):
           child = improvefeatures( child  )  #### the child have an improvement also for features of 0.01 perc

        FES.append( ( "DEATH", child , child.death )  )
        FES.append( ( "BORN" , child , timesystem + timebornchild )  )
        population.append(child)
        id+=1
    else:                 ##### no improvement
        newlifetime = uniform(0 , timeabs )
        if(newlifetime!=0):
          child = Specie( id , gen+1 , father , timesystem + timebornchild , timeabs ) ####### save features of the animal
          child.death =  timesystem + timebornchild + newlifetime
          child =  copyfeatures( child, father )   ####### save features of the animal
          improve = choice([0, 1], p=[1-0.5, 0.5])
          if(improve == 1):
            child = improvefeatures( child  )  #### the child have an improvement also for features of 0.01 perc

          FES.append( ( "BORN" , child , timesystem + newlifetime )  )
          FES.append( ( "DEATH", child , child.death )  )
          population.append(child)

          id+=1
        else:
          ### here is useless to create the object because the animal die right away , it is like an "abort", this probability that happen is very low
            tupla = data.rate[ father.name ]
            new_tuple = (tupla[0] , tupla[1]+1)
            data.rate[ father.name ]  = new_tuple
    tupla = data.rate[ child.name ]
    new_tuple = (tupla[0] + 1, tupla[1])
    data.rate[ child.name ]  = new_tuple

def mean_confidence_accuracy(array, CI=0.95):
    mean = array.mean()
    variance = np.var(array, ddof=1)
    num_samples = len(array)
    standard_error = np.sqrt(variance / num_samples)
    t_critical = t.ppf((1 + CI) / 2, num_samples - 1)
    delta = t_critical * (standard_error / np.sqrt(num_samples))

    confidence_interval = (mean - delta, mean + delta)

    relative_error = delta / mean
    accuracy = (1 - relative_error) * 100

    return mean, confidence_interval, accuracy ,standard_error

def interaction():
  global population , FES,  timesystem
  arr = np.array(population)
  n = len(arr)
  i=0
  interaction = []
  while i < n:
    j = i
    while j < n :
        if i == j:
            j += 1
            continue  # Do nothing if i is equal to j
        else:
          first_animal = arr[i].position
          second_animal = arr[j].position
          result = calculate_distance(first_animal ,second_animal )
          if( result < 500 ):
            interaction.append( (i, j ) )
        j += 1
    i += 1
  bool_row = np.zeros(n, dtype=bool)
  for i in interaction:

    if( bool_row[i[0]]== False and   bool_row[i[1]]== False ):  ### check if one animal among both is already dead
      tupla = fight_escape( i[0] , i[1]    )  ####go to fight escape and delete the print
      if( tupla[0]== True ):
          bool_row[ tupla[1] ] = True
  indices = np.where(bool_row)[0]  #### save the index of the True animal that will die

  copied_animals = np.copy(arr[indices])

  new_array = np.delete(arr, indices)
  population = new_array.tolist()   ##### pop in population


  events = []                                       #### here we are deleting the child generated by father of the animal death
  for a in copied_animals:
    id_father = a.id
    for elem in population:
      if(elem.father.id == id_father ):            #### check the object in the pop has the same father
        ####aggiungere elemento morto
        tupla = data.rate[ a.name ]
        new_tuple = (tupla[0] , tupla[1]+1)
        data.rate[ a.name ]  = new_tuple

        #value = data.gen.get(obj.generation)
        #print(value)
        v=data.gen.get( a.generation, (0, 0))
        data.gen[ a.generation ] =  (  v[0] + ( timesystem - a.timeborn ) , v[1] + 1 )


        born_event = elem.timeborn
        events.append(born_event)
  todelete=[]
  if(len(events)==0):
    for i in range(len(events)):
      i=0
      for el in FES:
        if(events[i]==el[2]):
          todelete.append(i)
          break
        i+=1
    for index in sorted(todelete, reverse=True):
      del FES[index]
  ### delete all child

def simulation():
  global FES , population, data
  ########## EVENT loop

  # Record the start time
  start_time = time.time()
  # Set the duration to 5 minutes (300 seconds)
  duration = 20
  i=0

  year = 1
  while time.time() - start_time < duration:
        event = FES.pop(0)
        tag= event[0]
        timesystem = event[2]
        #print("event " , tag, "time system ", timesystem , " cycle number ", i, "  the FES - pop  ", len(FES) ," - ", len(population)  )

        if(int(timesystem) > year ):    #### mobility per year
          print(" interaction   " , timesystem    )
          year= int(timesystem)
          movement()
          interaction()
          ########insert mobility event

        if(tag=="BORN"):
          born(event[1], event[2]  )
          FES = sorted(FES, key=lambda x: (x[2], x[0]))
        elif(tag=="DEATH"):
          death(event[1], event[2])
          FES = sorted(FES, key=lambda x: (x[2], x[0]))
        #print("event " , tag, "time system ", timesystem , " cycle number ", i, "  the FES - pop  ", len(FES) ," - ", len(population)  )

        i+=1
  print("fine")
  ###### i can add in the measure object the if the there is an extinction to compute the generation and the time


  return data

def setparameters( prob_improve , reproduction ):
  global timesystem  , lambdarate , id ,mean_lifetime ,FES , population, data
  prob_improve = prob_improve
  lambdarate = reproduction            ### better if we use 2

  alpha = 2

  timesystem=0

  id = 0
  # Set the mean lifetime for animals
  mean_lifetime = 20
  # Calculate the rate parameter (lambda) based on the mean
  lambda_param = 1 / mean_lifetime

  return prob_improve , lambdarate

def dataset():
  global FES, population, data ,timesystem
  for index, row in df.iterrows():
      id = index
      obj = Specie(index , 0 , None , 0, None )
      for index, value in row.items():
        if(index =="animal_name"):
          obj.name = value
        else:
          obj.features[index]= value
      obj = lethality (mobility(obj))
      x = randint(0, 1e6)
      y = randint(0, 1e6)
      obj.position = ( x , y )
      lifetime = uniform(10, 20)
      obj.parentlife = lifetime
      obj.death = lifetime
      obj.father = obj ##### the object himself
      obj.velocity = int( 1e4 * obj.mobility)  #### 1e4 =  10km      KM / year
      BORN = ( "BORN"  , obj , timesystem   )
      DEATH = ( "DEATH" , obj , obj.death   )
      FES.append(BORN)
      FES.append(DEATH)

      population.append(obj)
  id+=1
  FES = sorted(FES, key=lambda x: (x[2], x[0]))
  return FES, population

def randomAnimals(numberanimals=5):
  global population , FES, data
  random_elements = random.sample(population, numberanimals)
  newFES = []
  for p in random_elements:
    for fes in FES:
      if(fes[1]==p):
        newFES.append(fes)
  newFES = sorted(newFES, key=lambda x: (x[2], x[0]))
  FES = newFES

                           #### list of animals for the dictionary
  name_animals = []
  for p in random_elements:
      name_animals.append(p.name)

  data.rate = {value: (0,0) for value in name_animals}
  return FES , random_elements ,name_animals

reproduction_rate = [  2 , 3 ] #, 2, 3 ]
improv_prob = [ 0.4, 0.5 ] # , 0.5 , 0.6 ]

container = {}

timesystem = 0
FES = []
population = []
alpha = 2
data= Measure()
FES, population = dataset()
FES , population ,name_animals = randomAnimals()
pop = population
fes = FES
d = data

for repro in reproduction_rate:
  for improve in improv_prob:
      container[(repro,improve)] = []
      for i in range(30):
          population = pop
          FES = fes
          data = copy.deepcopy(data)  #### create differenct reference for measure obj
          prob_improve ,lambdarate =  setparameters( improve , repro )
          data = simulation()
          container[(repro,improve)].append(data)


dictionary = {}

for key, elements in container.items():
  dictionary[key] = []
  for el in elements:
    dictionary[key].append( compute_aggregation(el))


final_dictionary = {}
for k , lista in dictionary.items():
  final_dictionary[k] = {}
  for a in name_animals:
    final_dictionary[k][a] = []
  for l in lista:
    for key , perce in l.items():
        final_dictionary[k][key].append(( perce))

compacted_dict = {}
for k , lista in final_dictionary.items():
  compacted_dict[k] = {}
  for a in name_animals:
    compacted_dict[k][a] = []
  for key , lista in lista.items():
      array = np.array([])
      for el in lista:
        if not isinstance(el, tuple):
          array = np.append(array, el)
      mean , conf , acc, standard_error = mean_confidence_accuracy(array)
      compacted_dict[k][key].append(( mean , conf , acc, standard_error))  ### can be a run time becasue some values can be 0, so the accurary is 0



x = np.linspace(0, 1, 100)

for k, lista in compacted_dict.items():
    fig, ax = plt.subplots()

    for key, l in lista.items():
        #pdf_values1 = norm.pdf(x, l[0][0], l[0][3])
        plt.bar(key, l[0][0], label=f'{key} - mean {round(l[0][0], 2)} - CI ({round(l[0][1][0], 2)} - {round(l[0][1][1], 2)})  - ACC {round(l[0][2], 2)}')
        plt.text(key, l[0][0] + 0.05, f'{round(l[0][0], 2)}', ha='center', va='bottom')  # Display the value on top of the bar

    # Set labels and title
    plt.xlabel('Animals')
    plt.ylabel('Probability Density')
    plt.title(f'Probability of surviving improve prob. {k[1]} - reproduction rate {k[0]}')
    plt.legend(fontsize='small', loc='upper right')

    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.ylim(0, 1.5)

    plt.savefig(f'plot{k}.svg', format='svg')
    plt.savefig(f'plot{k}.png', format='png')
    plt.show()
